# 线程
标准线程由：
- 线程id
- 当前指令指针（pc）
- 寄存器集合和堆栈组合

各个线程共享程序的内存空间（代码段、数据段、堆）以及一些进程级的资源

通常使用多线程的原因呢：
- 某个操作可能会陷入长时间的等待
- 某个操作会消耗大量的时间
- 程序逻辑本身就要求多并发操作
- 多 cpu 多内核， 本身具备同时执行多个现成的能力
- 多线程在数据共享方面效率更高（！！）

## 线程的访问权限
线程可以访问：
- 进程内存里的所有数据
- 包括其他线程的堆栈

实际应用中线程也拥有自己的私有存储空间：
- 栈
- 线程局部存储（tls）
- 寄存器（包括 pc 寄存器）

换一个角度：
线程私有：
- 局部变量
- 函数的参数
- tls 数据

线程之间共享
- 全局变量
- 堆上的数据
- 函数里的静态变量
- 程序代码，任何线程都有权利读取并执行任何代码
- 打开的文件，a 线程打开的文件可以由 b 线程读写

## 线程调度与优先级
在单处理对应多线程的情况下，会有一种模拟出来的状态。
操作系统会让这些多线程程序轮流执行，每次执行一小段时间，这样每个线程就“看起来”同时运行。

这样一个不断在处理器上切换不同线程的行为称之为线程调度。

线程通常拥有至少三种状态：
- 运行：此时线程正在执行
- 就绪：此时线程可以立刻运行，但 cpu 已经被占用
- 等待：此时线程正在等待某一个事件（通常是i/o或同步）发生，无法执行

处于运行中的线程拥有一段可以执行的时间，这段时间称为时间片，当时间片用尽的时候，该进程进入就绪状态。
每当一个线程离开运行状态时，调度系统就会选择一个其他的就绪线程继续执行。

### 优先级调度
自动调整优先级。
例如，频繁的进入等待状态的线程比频繁进行大量计算，以至于每次都把时间片用尽的线程受欢迎的多。
- i/o密集型：频繁等待的线程
- cpu密集型：很少等待的线程

i/o 密集型 总比 cpu 密集型得到更大的提升

#### 饿死
一个线程被饿死，是指他的优先级较低，在它执行前，总有较高优先级的线程要执行。
为了避免饿死，调度系统会逐步提升等待过长时间得不到执行的线程的优先级。

线程的优先级改变的方式：
- 用户指定
- 根据进入等待的频繁程度
- 长时间得不到执行而被提升


## linux 的多线程
API: 线程和进程都成为 Task, 每一个任务概念上都类似于一个单线程的进程
但不同任务之间可以选择共享内存空间
因此在实际意义上，共享了同一个内存空间的多个任务构成了一个进程，这些任务也就成了这个进程里的线程 

fork: 函数产生了一个和当前进程完全一样的新进程，并和当前进程一样从 fork 函数里返回。fork 和原任务一起共享一个写时复制的内存空间。
写时复制：两个任务可以同时自由的读取内存，但任意一个任务试图对内存进行修改时，内存就会复制一份提供给修改方单独用。

fork 只能够产生本任务的镜像，因此须使用exec配合才能启动新任务。
exec 可以用新的可执行映像替换当前的可执行映像。

fork 和 exec 通常用于产生新任务，若要产生新线程，则使用 clone:
可以产生新的任务，从指定位置开始执行，并且共享当前进程的内存空间和文件等，如此就可以在实际效果上产生一个线程


## 线程安全 - 同步与锁
同步：一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。如此，对数据的访问被原子化了。
LOCK：每个线程在访问数据或资源时，会先试图获取锁，并在访问结束后释放锁，在锁已经被占用的时候试图获取锁时，线程会等待，知道锁重新可用。

### 二元信号量
它只有两种状态，占用与非占用。
它适合只能被唯一的线程独占访问的资源。

对于允许多个线程并发访问的资源，多元信号量简称信号量。
一个初始值为 N 的信号量 允许 N 个线程并发访问

### 互斥量
资源仅同时允许一个线程访问，但与信号量不同的是，互斥量是谁来锁谁释放

### 临界区
信号量和互斥量对任何进程可见，即一个进程创建了一个互斥量或信号量
临近区：仅限于本进程，其他进程无法获取该锁。

### 读写锁
对于同一个锁，读写锁有两种获取方式，共享的或独占的。

## 线程模型
用户线程
### 一对一模型






