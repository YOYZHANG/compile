## 线程
标准线程由：
- 线程id
- 当前指令指针（pc）
- 寄存器集合和堆栈组合

各个线程共享程序的内存空间（代码段、数据段、堆）以及一些进程级的资源

通常使用多线程的原因呢：
- 某个操作可能会陷入长时间的等待
- 某个操作会消耗大量的时间
- 程序逻辑本身就要求多并发操作
- 多 cpu 多内核， 本身具备同时执行多个现成的能力
- 多线程在数据共享方面效率更高（！！）

## 线程的访问权限
线程可以访问：
- 进程内存里的所有数据
- 包括其他线程的堆栈

实际应用中线程也拥有自己的私有存储空间：
- 栈
- 线程局部存储（tls）
- 寄存器（包括 pc 寄存器）

换一个角度：
线程私有：
- 局部变量
- 函数的参数
- tls 数据

线程之间共享
- 全局变量
- 堆上的数据
- 函数里的静态变量
- 程序代码，任何线程都有权利读取并执行任何代码
- 打开的文件，a 线程打开的文件可以由 b 线程读写

## 线程调度与优先级
在单处理对应多线程的情况下，会有一种模拟出来的状态。
操作系统会让这些多线程程序轮流执行，每次执行一小段时间，这样每个线程就“看起来”同时运行。

这样一个不断在处理器上切换不同线程的行为称之为线程调度。

线程通常拥有至少三种状态：
- 运行：此时线程正在执行
- 就绪：此时线程可以立刻运行，但 cpu 已经被占用
- 等待：此时线程正在等待某一个事件（通常是i/o或同步）发生，无法执行

处于运行中的线程拥有一段可以执行的时间，这段时间称为时间片，当时间片用尽的时候，该进程进入就绪状态。
每当一个线程离开运行状态时，调度系统就会选择一个其他的就绪线程继续执行。

### 优先级调度
自动调整优先级。
例如，频繁的进入等待状态的线程比频繁进行大量计算，以至于每次都把时间片用尽的线程受欢迎的多。
- i/o密集型：频繁等待的线程
- cpu密集型：很少等待的线程

i/o 密集型 总比 cpu 密集型得到更大的提升

#### 饿死
一个线程被饿死，是指他的优先级较低，在它执行前，总有较高优先级的线程要执行。
为了避免饿死，调度系统会逐步提升等待过长时间得不到执行的线程的优先级。

线程的优先级改变的方式：
- 用户指定
- 根据进入等待的频繁程度
- 长时间得不到执行而被提升


