## 游戏规则
less(): 比较元素
exch(): 交换位置

- 验证正确性
- 运行时间：计算比较和交换的数量，对于不交换元素的算法，会计算访问数组的次数
- 额外的内存使用

如何比较两种排序算法：
- 实现并调试他们；
- 分析他们的基本性质
- 对他们的相对性能作出猜想
- 用实验验证我们的猜想

代码段：
- sortCompare
- 

### 选择排序
- 找到数组中最小的元素， 将其和数组的第一个元素交换位置
- 在剩下的元素中找到最小的元素，将它与第二个元素交换位置

特点：
- 运行时间和输入无关：为了找出最小的元素而扫描数组并不能为下一遍扫描提供信息。无法很好的利用数组的初始信息。
- 数据移动是最少的：N 次交换，交换次数和数组大小是线性关系

算法复杂度：
- 对于长度为 N 的数组， N^2/2 次比较和 N 次交换
### 插入排序

特点：
- 运行时间取决于输入中元素的初始顺序，对部分有序的数组十分高效

算法复杂度：
- 对于随机排列的长度为 N 且主键不重复的数组，平均情况下插入排序要 N^2/4次比较 和 N^/4次交换
- 最坏的情况是 N^2/2 次比较和 N^2/2 次交换，最好情况下需要 N -1 次比较和 0 次交换

命题：
- 插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一
### 希尔排序
在插入排序的基础上改进
使数组中任意间隔为 h 的元素都是有序的

### 归并排序
- 分治思想，将左半边排序->将右半边排序->归并结果
### 快速排序
优点：
- 原地排序
- 耗时 NlgN






