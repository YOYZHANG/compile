## 符号表
- 数据结构
- 插入， 查找等算法

## 规约 
- 每个键只对应着一个值
- 若有重复，新值将代替旧值
- 键不能为空
 - 可利用 get 方法是否返回空来测试给定的键是否存在于符号表
 - 可以将空值作为 put 方法的第二个参数存入表中来实现删除

 ## 删除操作
 - 延时删除：键对应的值设为空，然后在某个时候删除所有为空的键
 - 即时删除： 立刻从表中删除指定的键

 ## 用例举例
- 跟踪算法在小规模输入下的行为测试用例
- 寻找更高效的性能测试用例

测试用例：会从标准输入中得到一列字符串并记录每个字符串的出现次数，遍历所有并找出出现频率最高的键，这是一种字典

st.put(word, num);
st.get(word);

研究符号处理大型文本的性能需要考虑两个因素：
- 每个单词都会被作为键进行搜索，因此处理性能和输入文本的单词总量有关
- 输入的每个单词都会被存入符号表，因此输入流中不同的单词的总数也相关
 
FrequencyCounter 的共性：
- 混合使用查找和插入的操作
- 大量的不同键
- 查找操作比插入操作多得多
- 虽然不可预测，但查找和插入操作并非随机

## 无序链表中的顺序查找
符号表中的数据结构中，一个简单的选择是链表。
每个节点存储一个键值对
get(): 遍历链表
equals(): 比较键
put(): 遍历链表

基于链表的实现以及顺序查找是非常低效的，无法满足需求


## 有序数组中的二分查找
一对平行的数组：一个存储键一个存储值
核心是 rank 方法，他返回表中小于给定键的键的数量
对于 get 方法，只要给定的键存在于表中， rank()方法就可以精确的告知在哪里。

对于 put 方法，只要给定的键存于表中， rank 方法就能够精确的告诉我们到哪里去更新它的值，以及当键不在表中时，将键存储到表的何处。

我们将所有更大的键向后移动一格来腾出位置，并将给定的键值分别插入到各自的数组中的合适位置。

```
get() {
    if (isEmpty) return null;
    let i = rank(key);
    if (i < n && keys[i] === key) {
        return vals[i]
    }
}
// 如果表中存在该键，则应该返回该键的位置，也即是表中小于它的键的数量
rank(key, lo, hi) {
    if (hi < lo) {
        return lo;
    }

    let mid = lo + (hi - lo)/2;
    let cmp = (key - keys[mid]);
    if (cmp < 0) {
        return rank(key, lo, mid - 1)
    }
    else if (cmp > 0) {
        return rank(key, mid + 1, hi)
    }
    else return mid;
}

put(key, val) {
    int i = rank(key);
    if (i < n && keys[i] === key) {
        vals[i] = val
        return
    }

    // ???
    for (let j = n; j > i; j--) {
        keys[j] = keys[j-1];
        vals[j] = vals[j-1];
    }

    keys[i] = key;
    vals[i] = val;
    N++;
}
```
rank 保留以下性质：
- 如果表中存在该键， rank 应该返回该键的位置，也就是表中小于它的建的数量。

// ？？
- 如果表中不存在该键，rank还是应该返回表中小于他的键的数量
